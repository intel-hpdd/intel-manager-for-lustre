# Set the time, so certs work below ALWAYS.
# Future NTP job will set it again,
# so preserving host's date is unecessary
import subprocess
from toolz import pipe
from toolz.curried import map as cmap
from toolz.dicttoolz import merge

ret = subprocess.call("date -s @{server_epoch_seconds} > /dev/null 2>&1", shell=True)

import sys
import httplib
import urllib2
import shlex
import os
import socket
import ssl
import json
import logging

# create Logger with a single file handler
aggregator_log = logging.getLogger('device_aggregator')
aggregator_log.setLevel(logging.DEBUG)

handler = logging.FileHandler('/var/log/chroma-agent.log')
handler.setLevel(logging.DEBUG)
handler.setFormatter(logging.Formatter('[%(asctime)s] aggregator %(name)s %(levelname)s %(message)s'))
aggregator_log.addHandler(handler)

SSL_DIR = '/var/lib/chroma/'

# The agent's private key, never shared
PRIVATE_KEY = os.path.join(SSL_DIR, 'private.pem')

# The agent's certificate, generated by the manager in response to a CSR
AGENT_CERT = os.path.join(SSL_DIR, 'self.crt')

# The root certificate used to authenticate the manager
AUTHORITY_CERT = os.path.join(SSL_DIR, 'authority.crt')

SETTINGS_DIR = os.path.join(SSL_DIR, 'settings')

cert_str = open(AUTHORITY_CERT).read()


def get_agent_url():
    return pipe(os.listdir(SETTINGS_DIR),
                cmap(lambda x: os.path.join(SETTINGS_DIR, x)),
                cmap(lambda x: json.loads(open(x).read())),
                list,
                merge)['url']


class VerifiedHTTPSConnection(httplib.HTTPSConnection):
    def connect(self):
        sock = socket.create_connection((self.host, self.port), self.timeout)
        if self._tunnel_host:
            self.sock = sock
            self._tunnel()
        self.sock = ssl.wrap_socket(sock, cert_reqs=ssl.CERT_REQUIRED, ca_certs=AUTHORITY_CERT)


class VerifiedHTTPSHandler(urllib2.HTTPSHandler):
    def __init__(self, connection_class=VerifiedHTTPSConnection):
        self.specialized_conn_class = connection_class
        urllib2.HTTPSHandler.__init__(self)

    def https_open(self, req):
        return self.do_open(self.specialized_conn_class, req)


def launch_command(cmd):
    args = shlex.split(cmd)
    debug = 'Command returned %d: stdout: "%s" stderr: "%s"'

    aggregator_log.info('Executing shell command with arguments: %s' % args)

    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()

    aggregator_log.debug(debug % (p.returncode, out, err))

    if p.returncode != 0:
        raise Exception(debug % (p.returncode, out, err))

    return out.strip()


def setup_keys():
    if not os.path.exists(SSL_DIR):
        os.makedirs(SSL_DIR)

    with open(AUTHORITY_CERT, 'w') as f:
        f.write(cert_str)

    return launch_command('openssl genrsa -out %s 2048' % PRIVATE_KEY)


def forward_to_manager():
    fqdn = socket.getfqdn()
    nodename = os.uname()[1]
    csr = launch_command("openssl req -new -subj /C=/ST=/L=/O=/CN=%s -key %s" % (fqdn, PRIVATE_KEY))

    data = json.dumps({'address': socket.gethostbyname(socket.gethostname()),
                       'fqdn': fqdn,
                       'nodename': nodename,
                       'version': 0,
                       'csr': csr,
                       'capabilities': []})

    try:
        import ipdb;ipdb.set_trace()
        aggregator_url = get_agent_url().replace('agent', 'device-aggregator')
        https_handler = VerifiedHTTPSHandler()
        url_opener = urllib2.build_opener(https_handler)
        url_opener.addheaders.append(('Content-Type', 'application/json'))
        handle = url_opener.open(aggregator_url, data)
        response = handle.readlines()
        handle.close()

        json_resp = json.loads(response[0])
        open(AGENT_CERT, 'w').write(json_resp['certificate'])
        return json_resp
    except urllib2.URLError, e:
        aggregator_log.exception("Cannot reach host/url %s: %s" % (reg_url, e))
        raise


def main():
    try:
        aggregator_log.info('Device aggregator started...')
        import ipdb;ipdb.set_trace()

        # Set up SSL keys and register with the manager using our
        # embeddd registration token
        setup_keys()
        # todo: make this forward device-scanner info to device-aggregator
        # endpoint
        response = forward_to_manager()

        aggregator_log.info('Device aggregator update completed...')

        print json.dumps(
            {{'host_id': registration_response['host_id'], 'command_id': registration_response['command_id']}})

        return 0

    except Exception, err:
        aggregator_log.exception('Error from agent-aggregator-script main():')
        return 1


if __name__ == '__main__':
    sys.exit(main())
